package cz.cvut.spipes.modules.tabular;

import cz.cvut.spipes.constants.CSVW;
import cz.cvut.spipes.exception.ResourceNotUniqueException;
import cz.cvut.spipes.exception.SPipesException;
import cz.cvut.spipes.modules.Mode;
import cz.cvut.spipes.modules.model.Column;
import cz.cvut.spipes.modules.model.Row;
import cz.cvut.spipes.modules.model.TableSchema;
import org.apache.jena.rdf.model.Resource;
import org.apache.jena.rdf.model.ResourceFactory;
import org.apache.jena.rdf.model.Statement;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.supercsv.io.ICsvListReader;

import java.io.IOException;
import java.util.*;

public class CSVReader implements TabularReader {

    ICsvListReader listReader;
    private int numberOfRows = 0;

    private static final Logger LOG = LoggerFactory.getLogger(CSVReader.class);

    public CSVReader(ICsvListReader listReader) {
        this.listReader = listReader;
    }

    @Override
    public List<String> getHeader() throws IOException {
        return Arrays.asList((listReader.getHeader(true))); // skip the header (can't be used with CsvListReader);
    }

    @Override
    public List<Column> getOutputColumns(List<String>header) {
        Set<String> columnNames = new HashSet<>();
        ArrayList<Column> columns = new ArrayList<>(header.size());

        for (String columnTitle : header) {
            String columnName = normalize(columnTitle);
            boolean isDuplicate = !columnNames.add(columnName);

            Column schemaColumn = new Column(columnName, columnTitle);

            columns.add(schemaColumn);
            schemaColumn.setTitle(columnTitle);
            if (isDuplicate) throwNotUniqueException(schemaColumn, columnTitle, columnName);
        }
        return columns;
    }

    @Override
    public Set<Row> getRows(TableSchema tableSchema,String sourceResourceUri, Mode outputMode){
        /*
        This method depends on getRowStatements and should be called only after getRowStatements because numberOfRows is
        counted there.
        TODO : Find a way to compute numberOfRows without reading the whole file once again.
        */
        Set<Row> rows = new HashSet<>();
        //for each row
        for(int rowNumber = 1;rowNumber <= numberOfRows;rowNumber++){
            // 4.6.1 and 4.6.3
            Row r = new Row();
            r.setDescribes(tableSchema.createAboutUrl(rowNumber));

            if (outputMode == Mode.STANDARD) {
                // 4.6.4
                r.setRownum(rowNumber);
                // 4.6.5
                r.setUrl(sourceResourceUri + "#row=" + (rowNumber + 1));
            }
            rows.add(r);
            // 4.6.6 - Add titles.
            // We do not support titles.
            // 4.6.7
            // In standard mode only, emit the triples generated by running
            // the algorithm specified in section 6. JSON-LD to RDF over any
            // non-core annotations specified for the row, with node R as
            // an initial subject, the non-core annotation as property, and the
            // value of the non-core annotation as value.
        }
        return rows;
    }

    @Override
    public List<Statement> getRowStatements(List<String>header, List<Column>outputColumns, TableSchema tableSchema) throws IOException {
        List<Statement>statements = new ArrayList<>();
        List<String> row;
        int rowNumber = 0;
        //for each row
        while ((row = listReader.read()) != null) {
            rowNumber++;

            for (int i = 0; i < header.size(); i++) {
                // 4.6.8.1
                Column column = outputColumns.get(i);
                String cellValue = getValueFromRow(row, i, header.size(), rowNumber);
                if (cellValue != null) statements.add(createRowResource(cellValue, rowNumber, column,tableSchema));
                //TODO: URITemplate

                // 4.6.8.5 - else, if value is list and cellOrdering == true
                // 4.6.8.6 - else, if value is list
                // 4.6.8.7 - else, if cellValue is not null
            }
        }
        numberOfRows = rowNumber;
        listReader.close();
        return statements;
    }

    private String normalize(String label) {
        return label.trim().replaceAll("[^\\w]", "_");
    }

    private void throwNotUniqueException(Column column, String columnTitle, String columnName) {
        throw new ResourceNotUniqueException(
                String.format("Unable to create value of property %s due to collision. " +
                                "Both column titles '%s' and '%s' are normalized to '%s' " +
                                "and thus would refer to the same property url <%s>.",
                        CSVW.propertyUrl,
                        columnTitle,
                        column.getTitle(),
                        columnName,
                        column.getPropertyUrl()));
    }

    private Statement createRowResource(String cellValue, int rowNumber, Column column, TableSchema tableSchema) {
        Resource rowResource = ResourceFactory.createResource(tableSchema.createAboutUrl(rowNumber));

        return ResourceFactory.createStatement(
                rowResource,
                ResourceFactory.createProperty(column.getPropertyUrl()),
                ResourceFactory.createPlainLiteral(cellValue));
    }

    private String getValueFromRow(List<String> row, int index, int expectedRowLength, int currentRecordNumber) {
        try {
            return row.get(index);
        } catch (IndexOutOfBoundsException e) {
            String recordDelimiter = "\n----------\n";
            StringBuilder record = new StringBuilder(recordDelimiter);
            for (int i = 0; i < row.size(); i++) {
                record
                        .append(i)
                        .append(":")
                        .append(row.get(i))
                        .append(recordDelimiter);
            }
            LOG.error("Reading input file failed when reading record #{} (may not reflect the line #).\n" +
                            " It was expected that the current record contains {} values" +
                            ", but {}. element was not retrieved before whole record was processed.\n" +
                            "The problematic record: {}",
                    currentRecordNumber,
                    expectedRowLength,
                    index+1,
                    record
            );
            throw new SPipesException("Reading input file failed.", e);
        }
    }

}
